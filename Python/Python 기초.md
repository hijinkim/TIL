# Python

> 귀도 반 로섬(Guido van Rossum)이 개발한 인터프리터 방식의 스크립트 언어



## 입출력

### 출력

* `print(출력 내용 [, sep = 구분자] [, end = 끝 문자])`



### 입력

* `변수 = input()`
* `변수 = int(input())`
* `변수1, 변수2 = map(int, input().split())`



## 변수

### 수치형

* 정수형
* 실수형
* 복소수형 : 실수부 + 허수부j



### 문자열

* 확장열
  * `\n` : 개행
  * `\t` : 탭
  * `\"` : 큰따옴표
  * ```\` ``` : 작은따옴표
  * `\\` : \문자
* 긴 문자열 : `"""`



### 진위형

* True
* False



### 컬렉션

* 리스트
* 튜플
* 딕셔너리
* 집합



## 연산자

### 산술 연산자

* `+` : 더하기
* `-` : 빼기
* `*` : 곱하기
* `/` : 나누기
* `**` : 거듭제곱
* `//` : 정수 나누기
* `%` : 나머지



## 조건문

### if , elif, else 문

```python
if 조건:
    명령
    
elif 조건:
    명령
    
else:
    명령
```



### 비교 연산자

* `==` : 같다
* `!=` : 같지 않다
* `<` , `>` : 크다, 작다
* `<=` , `>=` : 크거나 같다, 작거나 같다



### 논리 연산자

* `and` : 두 조건이 모두 참
* `or` : 두 조건 중 하나라도 참
* `not` : 주어진 조건이 아닐 때



## 반복문

### while 반복문

```python
while 조건:
    명령
```



### for 반복문

```python
for 제어변수 in 컬렉션:
    명령
    
for 제어변수 in range(시작, 끝, 증가값):
    명령
```



### break, continue

```python
for 제어변수 in 컬렉션:
    명령
    if 조건:
        break #반복문 탈출
    if 조건:
        continue #하나 건너뛰고 반복문 계속 실행
명령
```



## 함수

``` python
def 함수명(인수 목록):
    본체
    return 변수
```

* `pass` : 아무 동작도 하지 않음, 빈 코드 의미



### 인수

* `(*인수명)` : 가변 인수, 인수의 개수가 정해져 있지 않음, 튜플로 묶여서 전달, 인수 목록의 마지막에 와야 함, 2개 이상 사용 불가

* `(인수1 = 인수값, 인수 2 = 인수값)` : 키워드 인수, 이름 지정해서 순서 상관 없음, 위치 인수가 항상 먼저, 키워드 인수가 앞에 오면 뒤에 위치 인수 올 수 없음

* `(**인수명)` : 키워드 가변 인수, 여러 개의 키워드 인수를 전달하면 이름과 값의 쌍을 사전으로 만들어 전달

  ``` python
  def calcstep(**args):
      begin = args['begin']
      end = args['end']
      step = args['step']
      for num in range(begin, end + 1, step):
          ...
  
  calcstep(begin = 3, end = 5, step = 1)
  ```

* 인수의 기본값 : 기본값을 가지는 인수는 목록의 뒤쪽에 와야 함

  ``` python
  def calcstep(begin, end, step = 1):
      ...
  ```

  

### docstring

함수의 재활용성을 높이기 위해 자세한 함수 사용법이나 인수의 의미, 주의 사항을 남기는 공식적인 방법

`help(함수명)` 을 사용하여 docstring 출력 가능



## 문자열

### 슬라이스

* `[begin:end:step]` 
* 시작 위치 생략할 경우 0 적용
* 끝 위치 생략할 경우 문자열의 끝까지 추출
* 시작 위치는 포함, 끝 위치는 포함되지 않음, 끝 위치 직전의 문자까지만 추출



### 검색

* `find()` : 문자열 위치 조사, 없을 경우 -1 리턴
* `rfind()` : 뒤에서 검색 시작, 없을 경우 -1 리턴
* `index()` : 해당 문자 없을 경우 예외 발생
* `rindex()` : 뒤에서 검색
* `count()` : 문자의 개수 세기, 부문 문자열도 검색 가능



### 조사

* `단어 in 문자열` : 포함할 경우 True, 아니면 False 리턴
* `단어 not in 문자열` : 포함되어 있지 않은지 조사
* `startswith()` : 특정 문자열로 시작되는지 조사
* `endswith()` : 특정 문자열로 끝나는지 조사
* `isalpha()` : 알파벳인지
* `islower()`, `isupper()` : 소문자, 대문자인지
* `isspace()` : 공백인지
* `isalnum()` : 알파벳 또는 숫자인지
* `isdecimal()` , `isdigit()` , `isnumeric()` : 숫자인지
* `isdentifier()` : 명칭으로 쓸 수 있는 문자로만 구성되어 있는지
* `isprintable()` : 인쇄 가능한 문자로만 구성되어 있는지



### 변경

* `lower()` : 소문자로
* `upper()` : 대문자로
* `swapcase()` : 소문자는 대문자로, 대문자는 소문자로
* `capitalize()` : 문장의 첫 글자만 대문자로
* `title()` : 모든 단어의 첫 글자를 대문자로
* `strip()` : 양쪽 공백 제거
* `lstrip()` , `rstrip()` : 왼쪽 공백 제거, 오른쪽 공백 제거



### 분할

* `split()` : 구분자를 기준으로 문자열 분할, 인수 없을 경우 공백 기준
* `splitlines()` : 개행 문자나 파일 구분자, 그룹 구분자 등을 기준으로 분할
* `join()` : 문자열의 각 문자 사이에 다른 문자열 끼워 넣기



### 대체

* `replace()` : 첫 번째 인수로 검색할 문자열, 두 번째 인수로 바꿀 문자열 지정, 세 번째 인수로 바꿀 개수 지정
* `ljust()` : 좌측 정렬, 인수로 폭 지정
* `rjust()` : 우측 정렬, 인수로 폭 지정
* `center()` : 가운데 정렬



### 포맷팅

```python
year = 2021
print("올해는 " + str(year) + "년")
print("올해는 ", year, "년")
```

| 표식 |   설명    |
| :--: | :-------: |
|  %d  |   정수    |
|  %f  |   실수    |
|  %s  |  문자열   |
|  %c  | 문자 하나 |
|  %h  |  16진수   |
|  %o  |   8진수   |
|  %%  |  % 문자   |

```python
year = 2021
month = 1
day = 11
print("오늘은 %d년 %d월 %d일", %(year, month, day))
```

* `[-]폭[.유효자리수]서식`
  * `-` 지정시 왼쪽 정렬
  * `.` 기호로 소수점 이하 얼마까지 표시할 것인지 지정



### 신형 포맷팅

* `print("이름: {}, 나이: {}, 키: {}".format(name, age, height))`
* `print("이름: {1}, 나이: {2}, 키: {0}".format(height, name, age))`

* `print("이름: {name}, 나이: {age}, 키: {height}.format(name = "한결", age = 20, height = 160))`
* ``print("이름: {0:10s}, 나이: {1:5d}, 키: {2:7.2f}".format(name, age, height)`
* `print("이름: {0:^10s}, 나이: {1:>5d}, 키: {2:<7.2f}".format(name, age, height))` (< 왼쪽 정렬, > 오른쪽 정렬, ^ 가운데 정렬)



## 리스트

* `리스트명[범위1:범위2] = []` : 해당 범위의 요소 제거
* `리스트1 + 리스트2` : 두 리스트 연결
* `리스트 * 정수` : 요소를 정수 번 반복



### 리스트 Comprehension

* `[수식 for 변수 in  리스트 if 조건]`
  * `[n * 2 for n in rane(1, 11)]` #[2, 4, 6, 8, ... , 18, 20]
  * `[n * n for n in range(1, 11) if n % 3 == 0]` #[9, 36, 81]



### 삽입

* `append()` : 인수로 전달한 요소를 리스트 끝에 추가
* `insert()` : 삽입할 위치와 요소값 전달받아 리스트 중간에 삽입
* `extend()` : 호출한 리스트에 인자로 주어진 리스트 합침 (list1 = list1 + list2와 같음)



### 삭제

* `remove()` : 인수로 전달받은 요소값을 찾아 삭제, 해당 값 없으면 예외 발생, 2개 이상이면 처음 발견한 요소만 삭제
* `del 리스트[인덱스]` : 요소 하나 삭제
* `clear()` : 모든 요소 삭제
* `pop()` : 삭제한 요소 리턴, 인수 없으면 마지막 요소 삭제하고 리턴



### 검색

* `index()` : 특정 요소의 위치 찾기, 발견되지 않으면 예외
* `count()` : 특정 요소값의 개수 조사
* `len()` : 리스트의 길이
* `max()` : 리스트의 최대값
* `min()` : 리스트의 최소값
* `in` , `not in` : 요소가 있는지 검사



### 정렬

* `sort()` : 리스트 정렬, 오름차순 정렬
  * `sort(reverse = True)` : 내림차순 정렬
  * `sort(key = str.lower)` : 소문자로 바꾼 후 비교
* `reverse()` : 요소의 순서를 반대로 뒤집기
* `sorted()` : 정렬된 새로운 리스트 만들어서 리턴



## 튜플

> 튜플을 사용하는 이유는 리스트에 비해 속도가 빠르고 편집할 수 없어서 안정적이기 때문이다.

### unpacking

```python
tu = "가", "나", "다"
a, b, c = tu

#a = "가"
#b = "나"
#c = "다"
```



### 두 개 이상의 값 반환

```python
import time
def gettime():
    now = time.localtime()
    return now.tm_hour, now.tm_min #두 값이 튜플로 묶여 반환

result = gettime()
print('지금은 %d시 %d분 입니다' %(result[0], result[1]))
```



## 딕셔너리

* `get()` : 키가 없으면 None 리턴, 두 번째 인수로 대신 돌려줄 디폴트값 지정 가능
* `키 in 사전` : 키가 있으면 True, 없으면 False 리턴

* `사전[키] = 값` : 키가 이미 존재할 경우 기존 값 변경, 없는 키일 경우 새로운 키와 값 쌍이 추가
* `del[키]` : 해당 키를 찾아 값과 함께 삭제, 키가 없으면 예외 발생
* `keys()` : 키 리스트 리턴
* `values()` : 값 리스트 리턴
* `items()` : 키와 값을 튜플로 묶은 객체 리턴
* `update()` : 인수로 전달한 사전이 호출 사전에 병합, 중복되는 키 있으면 병합되는 키 값 적용



## 집합

> 집합은 중복을 허용하지 않음

* `set()`
* `add()` : 원소 추가
* `remove()` : 원소 제거
* `update()` : 집합끼리 결합, 합집합
* `집합1 & 집합2` , `집합1.intersection(집합2)` : 교집합
* `집합1 | 집합2` , `집합1.union(집합2)` : 합집합
* `집합1 - 집합2` , `집합1.difference(집합2)` : 차집합
* `집합1 ^ 집합2` , `집합1.symmetric_difference(집합2)` : 배타적 차집합
* `<= ` , `issubset()` : 부분집합인지 조사
* `>=` , `issuperset` : 포함집합인지 조사

